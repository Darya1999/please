// Laba 1: определяет точку входа для консольного приложения.
//

#include "stdafx.h" //просто текстовый файл кода с определениями и объявлениями
// .h это header, то есть заголовок. При компиляции берется все содержимое файла заголовка и вставляется вместо "include"
#include <iostream>
#include <bitset>
#include <cmath>
// хэдэры для данного проекта юзаются через кавычки (из папки проекта), а системные (определенный список папок) в угловых скобках
int main() //точка входа- оформлена в виде функции
		   // фрагмент кода имеющий свое имя (идентификатор)- функция
{
	std::cout << "Hello, world! \n";
	//esc-последовательность - служебные непечатываемые символы (переносы, возврат строки) включаются в строку через символ обратного слэша
	// при обратботке компилятор пропускает слэш, а вместо следующей буквы вставляет символ
	std::cout << "Hello, world!" << std::endl;
	// шаблон endl в конечном счете представляет тот же самый символ \n
	//  в некоторых системах требуется писать "/r /n" r-return, n-new line
	std::cout << "sizeof int = " << sizeof(int) << std::endl; //объект cout позволяет вместе с оператором (угловые скобки) позволяет выводит одновременно как строки, 
															  //так и переменные других типов не заботясь о преобразовании их в строку
															  // автоматически делает приведение типов данных в строке (конверт.туСтринг)
	std::cout << "sizeof short = " << sizeof(short) << std::endl;
	std::cout << "Sizeof char = " << sizeof(char) << std::endl;
	std::cout << "Sizeof double = " << sizeof(double) << std::endl;
	std::cout << "Sizeof boolean = " << sizeof(bool) << std::endl; //процессор не умеет работать с одиночными битами и даже с одиночными чарами
																   //  в ЦП есть 16 и 32 разрядные ячейки памяти, если вы загружаете чар или булеву функцию незанятые разряды будут нулевые
	std::cout << "Sizeof longint = " << sizeof(long) << std::endl;
	std::cout << "Sizeof longlong = " << sizeof(long long) << std::endl;
	std::cout << "Sizeof long long int = " << sizeof(long long int) << std::endl;
	std::cout << "Sizeof true = " << sizeof(true) << std::endl;
	std::cout << "Sizeof false = " << sizeof(false) << std::endl;
	// целые числа беззнаковые представлены в разрядах оперативной памяти, в разрядах регистра процессора в двоичном виде
	int a = INT_MAX; //объявление переменной типа инт, инициализация 
	int b = 0b10000000000000000000000000000000;
	int oct = 0100;
	int hex = 0xff;
	unsigned int bbu = 0b10000000000000000000000000000000; // если при объявлении использовано ансайнд, то число не может быть отрицательным 
														   //и его допустимый диапазон удваивается
														   // если к наибольшему знаковому целому прибавить единицу, происходит переполнение и выходит наименьшее отрицательное число
	std::cout << "a =" << std::bitset<32>(a) << std::endl;
	std::cout << "B =" << b << std::endl;
	std::cout << "OCT " << oct << std::endl;
	std::cout << "hex " << hex << std::endl;
	std::cout << "unsigned " << bbu << std::endl;
	int pr = INT_MAX;
	std::cout << "Before overflow " << pr << std::endl;
	pr = pr++;
	std::cout << "After overflow " << pr << std::endl;
	getchar();
	return 0; // возврат из main() - выход из программы
			  // getchar- ожидание ввода пользователя (один символ)
}
