// Massives.cpp: определяет точку входа для консольного приложения.

#include "stdafx.h"
#include <iostream>

using namespace std;

//все переменные которые создаются внутри функций выделяются в стековой памяти
//стековая память ограниченая- при неправильном использовании стек переполняется (stack overflow)
// размерности массивов, выделяемых в стековой памяти фиксированы и задаются константой

void fnc1()
{
	// int b[1000][1000] = { 0 }; - вызывает переполнение стека
}

int main()

{
	int l1 = 10, l2 = 15;
	// int arr[l1][l2] = { 0 }; в таком виде только константми задавать

	fnc1();

	//для использования свободной памяти ОС (heap-куча)
	//объявляются динамические переменные по синтаксису
	// указатель_на_тип имя переменной = new тип_переменной;
	// или
	// тип * имя_переменной= new тип;
	// работа с динамической памятью происходит через указатели
	// преимущества
	// 1. Доступно гораздо больше памяти нежели в стеке
	// 2. Размеры массивов и структур данных можно определять и менять
	// во время работы приложения
	// Особенность- если программа предназначена для длительной работы ,
	// во избежание переполнения памяти созданные блоки переменные и блоки должны
	// быть освобождены с помощью оператора delete:
	// delete имя_переменной;

	int * ptr_int = new int; // в нераспределенной памяти создает блок размером с int

							 // и указатель на него возвращается в переменную ptr_int

							 // вызов утечки памяти

	for (int i = 0; i < 10000; i++) {

		long long * b = new long long;

		//1. каждый заход в стеке создается новый указатель
		// 2. выделяется блок new long long; в куче (нераспределнной памяти), приписанной этой программе
		// 3. стэковая переменная b исчезает
		// 4. Блок по прежнему остается там же
		// 5. при следующем заходе выделяется новый блок
		// совершить нужные действия с переменной

		delete b; //удалить блок памяти, пока не потерян указатель на нее
				  // пара операторов new и delete это одно из нововведений в С++ относительно С
				  //в динамической памяти могут выделяться только одномерные массивы
				  // тип * имя_указателя = new тип[длина];
				  // удаляются одномерные массивы с помощью записи
				  // delete[] имя_указателя;

	}

	//для выделения двумерного массива сначала создается одномерный массив, содержащий указатели на другие массивы- строки
	// МОЖЕМ ЗАДАВАТЬ РАЗМЕРНОСТЬ МАССИВА ПЕРЕМЕННЫМИ
	int ** dynamic2Darray = new int *[l1];
	// затем выделяется блок памяти под каждую строку и указатель на нее возвращается в созданный массив указателей

	for (int i = 0; i < l1; i++)

	{
		dynamic2Darray[i] = new int[l2]; /*dynamic2Darray[i] имеет тип (int*) */
	}

	//освобождается в обратном порядке

	for (int i = 0; i < l1; i++)
	{
		delete dynamic2Darray[i];/*dynamic2Darray[i] имеет тип (int*) */
	}

	delete[] dynamic2Darray;
	getchar();
	return 0;

}